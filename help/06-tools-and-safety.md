<div align="center">

[English](06-tools-and-safety.md) | [中文](06-tools-and-safety.cn.md) | [Help](README.md)

</div>

# 06. Tools + Safety: execution and governance

## 6.1 End-to-end flow

A typical tool call flow:

1. LLM emits a `tool_call`
2. The framework computes an `approval_key` and enters the policy gate
3. denylist blocks early; allowlist may pass-through; otherwise approvals are requested
4. If `sandbox=restricted`, the OS sandbox adapter is applied
5. Execute the tool and emit `tool_call_finished`
6. Feed the result back to the LLM

## 6.2 Built-in tools (current)

- Exec: `shell_exec` / `shell` / `shell_command` / `exec_command` / `write_stdin`
- Files: `file_read` / `file_write` / `read_file` / `list_dir` / `grep_files` / `apply_patch`
- Interaction: `ask_human` / `request_user_input` / `update_plan`
- Skills: `skill_exec` / `skill_ref_read`
- Other: `view_image` / `web_search`
- Collaboration: `spawn_agent` / `wait` / `send_input` / `close_agent` / `resume_agent`

## 6.3 Approvals policy (gatekeeper)

Config entry:

```yaml
safety:
  mode: "ask"
  allowlist: ["ls", "pwd", "cat", "rg"]
  denylist: ["sudo", "rm -rf", "shutdown", "reboot"]
  tool_allowlist: []          # custom tools allowlist (exact tool name match)
  tool_denylist: []           # custom tools denylist (exact tool name match)
  approval_timeout_ms: 60000
```

Meaning:
- `mode=ask`: approvals by default
- allowlist: reduce interruptions for safe frequent commands
- denylist: block dangerous operations early
- `tool_allowlist/tool_denylist`: governs custom tools (non-builtin) for unattended runs: default is `ask`; only allowlisted tools can run without approvals; denylist blocks hard.

### 6.3.1 Programmatic approvals (recommended for cloud unattended)

Unattended automation does **not** mean “no approvals”. It means:

- no human clicks during the run
- approvals decisions are made by **code** (deterministic rules), with **fail-closed** defaults
- everything is still auditable (events/WAL), but without leaking secrets

If you don’t have a “human click” approval UI, inject a rule-based provider (fail-closed by default: anything unmatched is denied):

```python
from pathlib import Path
from skills_runtime.agent import Agent
from skills_runtime.safety import ApprovalRule, RuleBasedApprovalProvider
from skills_runtime.safety.approvals import ApprovalDecision

provider = RuleBasedApprovalProvider(
    rules=[
        # Example: only allow `shell_exec` when argv[0] is pytest (everything else denied)
        ApprovalRule(
            tool="shell_exec",
            condition=lambda req: (req.details.get("argv") or [None])[0] == "pytest",
            decision=ApprovalDecision.APPROVED,
        )
    ],
    default=ApprovalDecision.DENIED,
)

agent = Agent(
    workspace_root=Path(".").resolve(),
    backend=...,  # your LLM backend
    approval_provider=provider,
)
```

Notes:
- ApprovalRequest is generated by the SDK and minimally redacted (no env values, no file_write content plaintext, etc.).
- If `condition` raises, it’s treated as “not matched” (fail-closed).

#### 6.3.1.1 What the framework actually does (flow + events)

Think of approvals as a strict, auditable gate in front of risky execution paths:

```text
LLM tool_call
  │
  ├─ sanitize request (no secrets in WAL/UI)
  │
  ├─ approval_key = sha256(canonical_json(tool, sanitized_request))
  │
  ├─ policy gate (denylist / allowlist / safety.mode)
  │
  ├─ ApprovalProvider.request_approval(...)   (UI click OR programmatic rules)
  │
  ├─ cache? (approved_for_session)
  │
  └─ dispatch tool -> tool_call_finished
```

The WAL/SSE timeline will contain a stable sequence like:

```text
tool_call_requested
approval_requested
approval_decided (approved/denied/approved_for_session/abort)
tool_call_started      (only if approved)
tool_call_finished
```

This structure is where you get both:
- **security**: no execution without passing the gate
- **UX value**: fewer interruptions (allowlist + caching) while keeping a clear audit trail

For the deeper mechanics (sanitized request contract, approval_key, examples), see:
- `help/14-safety-deep-dive.md`

#### 6.3.1.2 “Approved for session” is a UX multiplier (without weakening safety)

Some approvals are extremely noisy in interactive scenarios (e.g., an `exec_command` session that needs repeated `write_stdin`).

When the decision is `approved_for_session`, the SDK caches the `approval_key` for the current run/session, so repeated identical requests can skip re-asking while still recording sanitized tool events.

```text
first call:  approval_requested -> approved_for_session -> tool executes
next calls:  approval_key hits cache -> skip approval_requested -> tool executes
```

This is especially useful for:
- PTY/exec sessions (`exec_command` + `write_stdin`)
- workflows that poll status repeatedly

#### 6.3.1.3 Rules that maximize safety *and* user experience

Principles:
- Prefer **argv-based** tools (`shell_exec`, `shell`) over raw shell strings (`shell_command`, `exec_command`).
  - shell strings may contain pipes/redirections/`&&` etc. In `safety.mode=ask`, “complex shell” is treated as approvals-required even when allowlist matches (to avoid accidental bypass).
- Approve narrow, low-risk operations; deny everything else.
- Keep allowlists small and readable; use rules for “context-sensitive” approvals.

Example: allow `pytest -q` only, and cache approvals for interactive exec sessions:

```python
from skills_runtime.safety import ApprovalRule, RuleBasedApprovalProvider
from skills_runtime.safety.approvals import ApprovalDecision

def _argv0(req):
    return (req.details.get("argv") or [None])[0]

provider = RuleBasedApprovalProvider(
    rules=[
        ApprovalRule(
            tool="shell_exec",
            condition=lambda req: _argv0(req) in ("pytest", "python"),
            decision=ApprovalDecision.APPROVED,
        ),
        ApprovalRule(
            tool="write_stdin",
            # allow polling output for an already-approved session
            condition=lambda req: True,
            decision=ApprovalDecision.APPROVED_FOR_SESSION,
        ),
    ],
    default=ApprovalDecision.DENIED,
)
```

### 6.3.2 Production-oriented unattended configuration recipes

The goal in unattended automation is:
- keep humans out of the critical path
- fail fast and explainably when something unsafe/unexpected happens
- reduce alert fatigue while preserving auditability

#### Recipe A: “safe-by-default CI runner”

```yaml
config_version: 1

safety:
  mode: "ask"
  # Keep this list short: frequent + safe.
  allowlist: ["pwd", "ls", "cat", "rg", "pytest"]
  # Always block obvious footguns early.
  denylist: ["sudo", "rm -rf", "mkfs", "dd", "shutdown", "reboot"]
  # If your ApprovalProvider is remote (HTTP/queue), keep a bounded wait.
  approval_timeout_ms: 5000

# Optional but recommended: restrict OS capabilities (fence).
sandbox:
  default_policy: "restricted"
  os:
    mode: "auto"

run:
  # If any human-facing input channel exists, bound it.
  human_timeout_ms: 3000
```

#### Recipe B: “no-human runs (strict)”

If a job must never require humans, keep `safety.mode=ask` but make the ApprovalProvider deterministic and fail-closed.
In this mode, anything not covered by your rules becomes a *clean, explainable* denial rather than a hang.

### 6.3.3 How this creates UX value

For end users, “good safety” is not just about blocking things—it’s about making the system predictable:

- Fewer unnecessary prompts: allowlist + `approved_for_session` caching
- Clear “why denied”: policy vs approvals vs sandbox failures are distinct in the event stream
- Auditable without secrets: sanitized requests are small, stable, and safe to log

## 6.4 Sandbox policy (fence)

### SDK default

- `sandbox.default_policy=none`

### Studio MVP baseline

- balanced: `default_policy=restricted` + `os.mode=auto`

### Platform mapping

- macOS: seatbelt (`sandbox-exec`)
- Linux: bubblewrap (`bwrap`)

## 6.5 `sandbox` parameter semantics

Tools may explicitly pass:

- `inherit`
- `none`
- `restricted`

Meaning:
- `inherit`: follow default policy
- `none`: do not use OS sandbox for this call
- `restricted`: force OS sandbox

If `restricted` is required but the adapter is unavailable: `sandbox_denied` (no silent fallback).

## 6.6 Exec Sessions (PTY)

Use for long-running or interactive commands:

1. `exec_command` starts and returns `session_id`
2. `write_stdin` sends input / polls output
3. session is cleaned up after process exits

## 6.7 Typical examples

### `shell_exec`

```json
{
  "argv": ["bash", "-lc", "pytest -q"],
  "cwd": ".",
  "timeout_ms": 120000,
  "sandbox": "inherit"
}
```

### `exec_command`

```json
{
  "cmd": "python -u -c \"print('ready'); import time; time.sleep(3)\"",
  "yield_time_ms": 50,
  "sandbox": "inherit"
}
```

### `write_stdin`

```json
{
  "session_id": 1,
  "chars": "hello\n",
  "yield_time_ms": 200
}
```

## 6.8 Error kinds (quick lookup)

- `validation`
- `permission`
- `not_found`
- `sandbox_denied`
- `timeout`
- `human_required`
- `cancelled`
- `unknown`

## 6.9 Baseline recommendations

1. Dev: `ask + allowlist + denylist + restricted (minimal profile)`
2. Prod: tighten allowlist and sandbox profile gradually
3. Treat `sandbox_denied` as a config/environment problem (not an acceptable silent fallback)

## 6.10 ToolSafetyDescriptor: tools self-describe their safety semantics

The `ToolSafetyDescriptor` protocol (`tools/protocol.py`) lets each tool declare how it should be treated by the safety gate — what counts as "risky", how to sanitize args for approvals/WAL, and which policy category applies.

```python
class ToolSafetyDescriptor(Protocol):
    policy_category: str  # e.g. "shell_exec", "file_write", "none"

    def extract_risk(self, args, **ctx) -> ...: ...
    def sanitize_for_approval(self, args, **ctx) -> ...: ...
    def sanitize_for_event(self, args, **ctx) -> dict: ...
```

The SDK ships 7 built-in descriptors in `safety/descriptors.py`:
`ShellExecDescriptor`, `ShellDescriptor`, `ShellCommandDescriptor`, `ExecCommandDescriptor`, `FileWriteDescriptor`, `ApplyPatchDescriptor`, `SkillExecDescriptor`, `WriteStdinDescriptor`.

For custom tools without a descriptor, `PassthroughDescriptor` is used as a fallback (low risk, args passed through as-is).

`SafetyGate` (`safety/gate.py`) replaces the old `if/elif` dispatch chain in the agent loop. It receives a `get_descriptor` callable and routes each tool call through the appropriate descriptor before making a policy/approval decision.

When registering a custom tool, you can optionally supply a descriptor:

```python
from skills_runtime.tools.protocol import ToolSafetyDescriptor

class MyDescriptor:
    policy_category = "shell_exec"  # reuse shell_exec policy path

    def extract_risk(self, args, **ctx):
        return {"argv": args.get("argv", []), "risk_level": "medium", "reason": "custom"}

    def sanitize_for_approval(self, args, **ctx):
        return {"argv": args.get("argv", [])}

    def sanitize_for_event(self, args, **ctx):
        return {"argv": args.get("argv", [])}

agent.register_tool(spec, handler, override=False)
# descriptor support: see help/08-architecture-internals.md §8.6
```

## 6.11 Further reading

- `help/sandbox-best-practices.md`
- `help/04-cli-reference.md`
- `help/09-troubleshooting.md`
- Code entrypoints: `packages/skills-runtime-sdk-python/src/skills_runtime/tools/*`, `packages/skills-runtime-sdk-python/src/skills_runtime/safety/*`, `packages/skills-runtime-sdk-python/src/skills_runtime/sandbox.py`

---

Prev: [05. Skills Guide](05-skills-guide.md) · Next: [07. Studio Guide](07-studio-guide.md)
